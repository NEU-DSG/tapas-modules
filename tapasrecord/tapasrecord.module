<?php

define("TAPAS_VALIDATION_XSLT_SUBDIRECTORY", "/validate/");
define("TAPAS_SAVE_FILE_ROOT_DIRECTORY", "public://tapasrecord");
define("TAPAS_TFC_TRANSFORM_FILENAME", "tfc_transform.xsl");
define("TAPASRECORD_SHOW_INTERNAL_ERRS", TRUE);

define("TAPAS_ERROR_MESSAGE_OUR_END", t("There seems to be a problem at our end, trying to process this file. " .
	"Please open a support ticket showing the following error message, and we'll get it fixed as soon as we can!"));
define("TAPAS_ERROR_MESSAGE_FILE_ERR", t("We are unable to process this file. This could be because of a problem " .
	"with the XML in the file itself, or, it might be valid TEI that we are not yet equipped to handle. If you are " .
	"confident that the TEI is valid, please open a support ticket so that we can (hopefully!) improve our system."));
define("TAPAS_ERROR_MESSAGE_UNKNOWN", t("We are unable to upload this file; please double-check that it is the " .
	"correct one."));

// TODO: Use private file system rather than public
// TODO: Properly set path of saved files (project, collection).
// TODO: Make TEI field mandatory for new (NOT updated) TAPAS Record nodes
// TODO: REmove the TFC field, since we don't need that to be a field.
// TODO: Handle TEI upload name collisions

// TODO: Settings page to choose public or private?
// TODO: Settings page to choose XSLT subdirectory?
// TODO: Settings page to choose name/location of transform file?
// TODO: Should each *record* have a folder, for the tei, tfc, and all attatchments?
//       tapasrecord/project/collection/node_id_num/

/**
 * @file
 * tapasrecord.module TAPAS TEI upload and transformation
 * 
 * defines tapas_record conent type, performs
 * TEI upload and validation, calls TFC transform.
 */

/**
 * implements hook_node_info()
 *
 * Defines the TAPAS record content type
 *
 * I considered making this an entity rather than a node, since node brings
 * along extra baggage that we don't need. However, Drupal's access-control
 * system is node-based; therefore, it would be far more difficult to enforce
 * access restrictions on a custom entity than on a custom node type.
 */

function tapasrecord_node_info()
{
  return array(
    'tapasrecordnode' => array(
      'name' => t('TAPAS Record'),
      'base' => 'tapasrecordnode',
      'description' => t('Holds a TEI record along with it\'s associated metadata and TFC'),
      'has_title' => TRUE,
      'title_label' => t('Record Title'),
      'help' => '',
    ),
  );
}

/** 
 * implements hook_form()
 * 
 * This has to be present even if it's just a pass-through,
 * otherwise the content type won't appear in the 
 * admin/structure/types list 
 */
function tapasrecordnode_form($node, $form_state) {
  return node_content_form($node, $form_state);
}

/** 
 * Implements hook_form_FORM_ID_alter().
 */

// Node creation/editing form should not show the TFC file field.
function tapasrecord_form_tapasrecordnode_node_form_alter(&$form, &$form_state, $form_id) {

	// hide the TFC field
	$form['tapas_tfcfield']['#access'] = FALSE;


	// TAPAS TEI field
	$form['tapas_teifield'][LANGUAGE_NONE][0] = array_merge(
    $form['tapas_teifield'][LANGUAGE_NONE][0],
		_tapasrecord_form_teifield($form_id)
	);

}

function _tapasrecord_form_teifield($form_id) {
	return array(
		'#type' => 'managed_file',
		'#title' => t('TEI file'),
		'#description' => t('allowed extentions: .tei, .xml'),
		'#upload_location' => _tapasrecord_get_file_upload_location(),
		'#upload_validators' => array(
			'file_validate_extensions' => array('tei xml'),
			'tapasrecord_validate_tei' => array($form_id),
		),
  );

}

function _tapasrecord_get_file_upload_location() {
	// TODO: will add subdirectories for project and collections, and add a directory_prepare
	return TAPAS_SAVE_FILE_ROOT_DIRECTORY;
}



/**
 * Callback to run the validation XSLT checks on the TEI file.
 */
function tapasrecord_validate_tei($file, $form_id) {

	$errors = array();

	$err_msg = TAPAS_ERROR_MESSAGE_FILE_ERR . ": Unable to load the TEI file.";
	$teiDOM = tapasrecord_domdoc_load($file->uri, $err_msg, $errors);
	if ($errors) {
		return $errors;
	}

	$errors = _tapasrecord_validate_xslt($teiDOM);
	if ($errors) {
		return $errors;
	}

	return _tapasrecord_run_transform($teiDOM, $file);
}

// ===========================================
// XSLT Processing
// ===========================================

/**
 * Runs the validation scripts on the given TEI file, returns any errors
 *
 * If errors are found at certain stages, the function my return the 
 * error list early rather than continuing to run the rest of the validation
 * checks.
 * 
 * @param $teiDOM: the DocumentDOM object containing the TEI file
 *
 * @return an array of strings, containing any errors found
 */
function _tapasrecord_validate_xslt($teiDOM) {

	$errors = array();

	$xsltDOM = new DOMDocument();
	$xslt_path = drupal_get_path('module', 'tapasrecord') . TAPAS_VALIDATION_XSLT_SUBDIRECTORY;
	$iterator = new \DirectoryIterator($xslt_path);

	foreach ($iterator as $next_xslt) {
		$ext = $next_xslt->getExtension();
		if ($ext == 'xsl' || $ext == 'xslt') {
			$err_msg = TAPAS_ERROR_MESSAGE_FILE_ERR . 
				": [Unable to validate the TEI file. using " . $next_xslt->getPathname() . "]";
			$result = tapasrecord_apply_stylesheet($next_xslt->getPathname(), $teiDOM, $errors, $err_msg);
		
			// $errors contains any libxml errors encountered while trying to run the validation
			// $result contains one of:
			//		FALSE, if the xslt was unable to rune
			//		an empty string, if the xslt ran without errors
			//		a non-empty string, containing the validation error,
		
			if ($result === FALSE) {
				$errors[] = TAPAS_ERROR_MESSAGE_UNKNOWN;
				return $errors;
			} elseif ($result) {
				$errors[] = $result;
				return $errors;
			}
			
		} // if $ext xsl or xslt
	} // foreach

	return $errors;
}

/**
 * Create the TFC from the uploaded TEI file.
 *
 * @param $teiDOM: the DocumentDOM object containing the TEI file to transform
 * @param $file: the Drupal file object, so we can get the non-temp name.
 *
 * @return: an array of strings containing any errors found (an empty array if none)
 */

function _tapasrecord_run_transform($teiDOM, $file) {

	$transform_path = drupal_get_path('module', 'tapasrecord') . '/' . TAPAS_TFC_TRANSFORM_FILENAME;
	$errors = array();
	$err_msg = t("Unable to process the TEI file.");	
	$tfc_result = tapasrecord_apply_stylesheet($transform_path, $teiDOM, $errors, $err_msg);

	if ($errors || !$tfc_result) {
		$errors[] = TAPASRECORD_ERROR_MESSAGE_UNKNWON;
		return $errors;
	}

	$basename = preg_replace('/\.[^.]+$/','',$file->filename);
	$tfc_saveloc = _tapasrecord_get_file_upload_location() . '/' . $basename . "_TFC.xml";

	file_unmanaged_save_data($tfc_result, $tfc_saveloc, FILE_EXISTS_REPLACE);

	return $errors;

}





// ----------------------------------------------
// XSLT Helpers
// ----------------------------------------------


/**
 * Loads the file at $filepath to a DocumentDOM
 *
 * @param $filepath: which file to load into the DOM
 * @param $err_msg: Custom error message to display if there are problems
 * @param &$errors: any non-supressed error strings will be added to this array
 * @param $show_raw: whether to include the raw libxml errors in &$errors
 *
 * @return The DocumentDOM containing the file at $filepath
 */
function tapasrecord_domdoc_load($filepath, $err_msg, &$errors, $show_raw=TRUE) {
	$docDOM = new DOMDocument();
	_tapasrecord_libxml_call($docDOM, 'load', $filepath, $err_msg, $errors, $show_raw);
	
	return $docDOM;

}

/**
 * Applies a stylesheet to an XML DOM
 *
 * @param $xsltpath: the stylesheet to apply
 * @param $xmlDOM: a DocumentDOM containing the xml file on which to run it
 * @param $&errors: any error strings will be added to this array
 * @param $result_err_msg: error to display if there are problems running the XSLT
 *
 * @return the transformed data, as a string
 */
function tapasrecord_apply_stylesheet($xsltpath, $xmlDOM, &$errors, $result_err_msg) {
	
	$err_msg = TAPAS_ERROR_MESSAGE_OUR_END . ": [unable to read xslt at $xsltpath]";
	$xsltDOM = tapasrecord_domdoc_load($xsltpath, $err_msg, $errors, TAPASRECORD_SHOW_INTERNAL_ERRS);

	if ($errors) {
		return FALSE;
	}
	
	$proc = new \XSLTProcessor();	
	$err_msg = TAPAS_ERROR_MESSAGE_OUR_END . ": [unable to import the xslt stylesheet at $xsltpath]";

	_tapasrecord_libxml_call($proc, 'importStylesheet', $xsltDOM, $err_msg, $errors, TAPASRECORD_SHOW_INTERNAL_ERRS);
	if ($errors) {
		return FALSE;
	}

	$result =  _tapasrecord_libxml_call($proc, 'transformToXML', $xmlDOM, $result_err_msg, $errors, TRUE);
	return $result;
}


/**
 * Runs a libxml function and takes control of the error display.
 *
 * libxml displays errors on the webpage that cannot be caught as exceptions-- the only
 *    way (to my knowledge) to prevent the raw error from being displayed to the user
 *    is to temporarily hijack libxml's error reporting. I dislike
 *    supressing errors, but we want to be able to provide a non-confusing message if,
 *    for instance, the user tries to upload a non-xml file in the TEI field.
 *
 * @param &$obj: the object on which to run the function
 * @param $func: the name of the function to call
 * @param $param: parameter to give the function (currently only one param supported)
 * @param $err_msg: Custom error message to display if there are any errors
 * @param &$errors: array in which to return all non-suppressed errors
 * @param $show_raw: also show the libxml errors, prefixed with "(more info:"
 *
 * @return Returns the result that the called function returns.
 */
function _tapasrecord_libxml_call(&$obj, $func, $param, $err_msg, &$errors, $show_raw=TRUE) {

	assert(is_callable(array($obj, $func)));

	libxml_use_internal_errors(TRUE);

	$result = call_user_func(array($obj, $func), $param);

	$libxml_errors = libxml_get_errors();
	if ($libxml_errors) {
		$errors[] = $err_msg;
		if ($show_raw) {
			foreach ($libxml_errors() as $e) {
				$errors[] = "(More info on why: " . $e->message . ")";
			}
		}
	}
		
	libxml_clear_errors();
	// give libxml control of its own error handling again.
	libxml_use_internal_errors(FALSE);

	return $result;

}
