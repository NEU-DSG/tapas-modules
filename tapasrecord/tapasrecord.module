<?php

define("TAPAS_VALIDATION_XSLT_SUBDIRECTORY", "/validate/");
define("TAPAS_SAVE_FILE_ROOT_DIRECTORY", "public://tapasrecord");
define("TAPAS_TFC_TRANSFORM_FILENAME", "tfc_transform.xsl");

/**
 * @file
 * tapasrecord.module TAPAS TEI upload and transformation
 * 
 * defines tapas_record conent type, performs
 * TEI upload and validation, calls TFC transform.
 */

/**
 * implements hook_node_info()
 *
 * Defines the TAPAS record content type
 *
 * I considered making this an entity rather than a node, since node brings
 * along extra baggage that we don't need. However, Drupal's access-control
 * system is node-based; therefore, it would be far more difficult to enforce
 * access restrictions on a custom entity than on a custom node type.
 */

function tapasrecord_node_info()
{
  return array(
    'tapasrecordnode' => array(
      'name' => t('TAPAS Record'),
      'base' => 'tapasrecordnode',
      'description' => t('Holds a TEI record along with it\'s associated metadata and TFC'),
      'has_title' => TRUE,
      'title_label' => t('Record Title'),
      'help' => '',
    ),
  );
}

/** 
 * implements hook_form()
 * 
 * This has to be present even if it's just a pass-through,
 * otherwise the content type won't appear in the 
 * admin/structure/types list (I have no idea what the
 * connection is, or why)
 */
function tapasrecordnode_form($node, $form_state) {
  return node_content_form($node, $form_state);
}

/** 
 * Implements hook_form_FORM_ID_alter().
 */

// Node creation/editing form should not show the TFC file field.
function tapasrecord_form_tapasrecordnode_node_form_alter(&$form, &$form_state, $form_id) {

	// hide the TFC field
	$form['tapas_tfcfield']['#access'] = FALSE;


	// TAPAS TEI field
	$form['tapas_teifield'][LANGUAGE_NONE][0] = array_merge(
    $form['tapas_teifield'][LANGUAGE_NONE][0],
		_tapasrecord_form_teifield($form_id)
	);

  // TODO: if this is a new (rather than edited) node, make tei field mandatory

}

function _tapasrecord_form_teifield($form_id)
{
	return array(
		'#type' => 'managed_file',
		'#title' => t('TEI file'),
		'#description' => t('allowed extentions: .tei, .xml'),
		'#upload_location' => _tapasrecord_get_file_upload_location(),
		'#upload_validators' => array(
			'file_validate_extensions' => array('tei xml'),
			'tapasrecord_validate_tei' => array($form_id),
		),
  );

}

function _tapasrecord_get_file_upload_location() {
	// TODO: will add subdirectories for project and collections, and add a directory_prepare
	return TAPAS_SAVE_FILE_ROOT_DIRECTORY;
}

/**
 * Callback to run the validation XSLT checks on the TEI file.
 *
 */
function tapasrecord_validate_tei($file, $form_id) {

	file_unmanaged_save_data("This is a test.", "public://tapasrecord/this_is_a_test.txt");

	$errors = array();
	// The error that the DOMDocument throws to the screen if the file is not
	// loadable is NOT an Exception, and CANNOT be caught with a try/catch block.
	// Therefore, in order to prevent the user from getting an libxml error when they
	// try to upload a non-xml file, we need to temporarily hijack libxml's error
	// handling.
	libxml_use_internal_errors(TRUE);

	$teiDOM = new DOMDocument();
	if (!$teiDOM->load($file->uri)) {
		$errors[] = "Unable to read the TEI file.";
		foreach (libxml_get_errors() as $e) {
			$errors[] = "(More info on why: " . $e->message . ")";
		}

		libxml_clear_errors();
		libxml_use_internal_errors(FALSE);
		return $errors;
	}

	// Give libxml back the ability to post errors
	libxml_use_internal_errors(FALSE);

	$errors = _validate_xslt($teiDOM);
	if ($errors) {
		return $errors;
	}
	// if there were no errors returned by _validate_xslt, 
	// then attempt to run the TFC transform before returning.
	//$tfc_result = _run_transform($teiDOM, drupal_get_path('module', 'tapasrecord') . '/' . TAPAS_TFC_TRANSFORM_FILENAME);

	//$teiDOM = new DOMDocument();
	//$teiDOM->load($tei_path);

	$xsltDOM = new DOMDocument();
	$xsltDOM->load(drupal_get_path('module', 'tapasrecord') . '/' . TAPAS_TFC_TRANSFORM_FILENAME);

	$proc = new XSLTProcessor();
	$proc->importStylesheet($xsltDOM);	

	$tfc = new DOMDocument();
	$tfc_result = $proc->transformToXML($teiDOM);

	// TODO: Handle any errors
	

	if ($tfc_result) {
		$tfc_saveloc = _tapasrecord_get_file_upload_location() . '/' . drupal_basename($file->uri) . "_TFC.xml";

		drupal_set_message("Attempting to save TFC file to " . $tfc_saveloc);
		drupal_set_message("file upload location result: " . _tapasrecord_get_file_upload_location());
		drupal_set_message("basename: " . drupal_basename($file->uri));
		file_unmanaged_save_data($tfc_result, $tfc_saveloc, FILE_EXISTS_REPLACE);
	} else {
		$errors[] = t("The TAPAS system was unable to handle this TEI file. This may mean there " .
			"is something wrong with the file, or it may mean that it contains valid TEI that our " .
			"system is not yet equiped to handle. If you are confident that the TEI is valid, then " .
			"please email 'info [at] tapasproject [dot] org' with the file so that we can determine " .
			"why it is failing, and whether the system can be made to accomadate it.");
	}

	return $errors;
}


function _validate_xslt($teiDOM) {

	$errors = array();



	$xsltDOM = new DOMDocument();
	$xslt_path = drupal_get_path('module', 'tapasrecord') . TAPAS_VALIDATION_XSLT_SUBDIRECTORY;
	$iterator = new \DirectoryIterator($xslt_path);

	foreach ($iterator as $next_xslt) {
		$ext = $next_xslt->getExtension();
		if ($ext == 'xsl' || $ext == 'xslt') {

			// Create an XSLT Processor with the XSLT file found.
			$xsltDOM->load($next_xslt->getRealPath());
			$proc = new \XSLTProcessor();
			$proc->importStylesheet($xsltDOM);
			$result = $proc->transformToXML($teiDOM);

			// if the result is FALSE, the xsl was unable to run.
			// if the result is a non-empty string, the xsl returned an error
			// if the result is an empty string, there were no errors.
			if ($result === FALSE) {
				$errors[] = "Unable to run transform on this file. Are you sure its valid XML?";
			} elseif ($result) {
			  $errors[] = $result;
		  }
		}
	}

	return $errors;
}

/**
 * Run an XSLT Transform on an XML File
 *
 * Used to run the TFC transform on the original TEI file, but
 * function is more general.
 *
 * Eventually the actual transform will be moved to eXist, at
 * which point this function can be removed if it isn't being
 * used by any other process.
 *
 * @param $tei_file
 * @param $xslt_file
 *
 * @return string the TFC
 */
function _run_transform($teiDOM, $xslt_path) {

}
