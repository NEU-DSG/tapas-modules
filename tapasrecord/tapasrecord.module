<?php

define("TAPAS_VALIDATION_XSLT_SUBDIRECTORY", "/validate/");
define("TAPAS_SAVE_FILE_ROOT_DIRECTORY", "public://tapasrecord");
define("TAPAS_TFC_TRANSFORM_FILENAME", "tfc_transform.xsl");

// TODO: Use private file system rather than public
// TODO: Properly set path of saved files (project, collection).
// TODO: Make TEI field mandatory for new (NOT updated) TAPAS Record nodes

// TODO: Settings page to choose public or private?
// TODO: Settings page to choose XSLT subdirectory?
// TODO: Settings page to choose name/location of transform file?

/**
 * @file
 * tapasrecord.module TAPAS TEI upload and transformation
 * 
 * defines tapas_record conent type, performs
 * TEI upload and validation, calls TFC transform.
 */

/**
 * implements hook_node_info()
 *
 * Defines the TAPAS record content type
 *
 * I considered making this an entity rather than a node, since node brings
 * along extra baggage that we don't need. However, Drupal's access-control
 * system is node-based; therefore, it would be far more difficult to enforce
 * access restrictions on a custom entity than on a custom node type.
 */

function tapasrecord_node_info()
{
  return array(
    'tapasrecordnode' => array(
      'name' => t('TAPAS Record'),
      'base' => 'tapasrecordnode',
      'description' => t('Holds a TEI record along with it\'s associated metadata and TFC'),
      'has_title' => TRUE,
      'title_label' => t('Record Title'),
      'help' => '',
    ),
  );
}

/** 
 * implements hook_form()
 * 
 * This has to be present even if it's just a pass-through,
 * otherwise the content type won't appear in the 
 * admin/structure/types list (I have no idea what the
 * connection is, or why)
 */
function tapasrecordnode_form($node, $form_state) {
  return node_content_form($node, $form_state);
}

/** 
 * Implements hook_form_FORM_ID_alter().
 */

// Node creation/editing form should not show the TFC file field.
function tapasrecord_form_tapasrecordnode_node_form_alter(&$form, &$form_state, $form_id) {

	// hide the TFC field
	$form['tapas_tfcfield']['#access'] = FALSE;


	// TAPAS TEI field
	$form['tapas_teifield'][LANGUAGE_NONE][0] = array_merge(
    $form['tapas_teifield'][LANGUAGE_NONE][0],
		_tapasrecord_form_teifield($form_id)
	);

}

function _tapasrecord_form_teifield($form_id)
{
	return array(
		'#type' => 'managed_file',
		'#title' => t('TEI file'),
		'#description' => t('allowed extentions: .tei, .xml'),
		'#upload_location' => _tapasrecord_get_file_upload_location(),
		'#upload_validators' => array(
			'file_validate_extensions' => array('tei xml'),
			'tapasrecord_validate_tei' => array($form_id),
		),
  );

}

function _tapasrecord_get_file_upload_location() {
	// TODO: will add subdirectories for project and collections, and add a directory_prepare
	return TAPAS_SAVE_FILE_ROOT_DIRECTORY;
}

/**
 * Callback to run the validation XSLT checks on the TEI file.
 *
 */
function tapasrecord_validate_tei($file, $form_id) {

	$errors = array();

	$teiDOM = new DOMDocument();
	$errors = _tapasrecord_dom_load($file->uri, $teiDOM, t("Unable to load the TEI file."));
	if($errors) {
		return $errors;
	}

	$errors = _validate_xslt($teiDOM);
	if ($errors) {
		return $errors;
	}

	$transform_path = drupal_get_path('module', 'tapasrecord') . '/' . TAPAS_TFC_TRANSFORM_FILENAME;
	$xsltDOM = new DOMDocument();
	$err_msg = t("There appears to be an error on our end: 'can't find the TFC Transform'. Please open a " . 
		"support ticket with the text of this error, and we'll get it fixed as quickly as possible!");
	$errors = _tapasrecord_dom_load($transform_path, $xsltDOM, $err_msg);
	if ($errors) {
		return $errors;
	}

	$proc = new XSLTProcessor();
	$proc->importStylesheet($xsltDOM);	

	//$tfc = new DOMDocument();
	$tfc_result = $proc->transformToXML($teiDOM);

	if ($tfc_result) {
		$basename = preg_replace('/\.[^.]+$/','',$file->filename);
		$tfc_saveloc = _tapasrecord_get_file_upload_location() . '/' . $basename . "_TFC.xml";

		file_unmanaged_save_data($tfc_result, $tfc_saveloc, FILE_EXISTS_REPLACE);
	} else {
		$errors[] = t("The TAPAS system was unable to handle this TEI file. This may mean there " .
			"is something wrong with the file, or it may mean that it contains valid TEI that our " .
			"system is not yet equiped to handle. If you are confident that the TEI is valid, then " .
			"please email 'info [at] tapasproject [dot] org' with the file so that we can determine " .
			"why it is failing, and whether the system can be made to accomadate it.");
	}

	return $errors;
}


function _validate_xslt($teiDOM) {

	$errors = array();

	$xsltDOM = new DOMDocument();
	$xslt_path = drupal_get_path('module', 'tapasrecord') . TAPAS_VALIDATION_XSLT_SUBDIRECTORY;
	$iterator = new \DirectoryIterator($xslt_path);

	foreach ($iterator as $next_xslt) {
		$ext = $next_xslt->getExtension();
		if ($ext == 'xsl' || $ext == 'xslt') {

			// Create an XSLT Processor with the XSLT file found.
			$xslt_error = _tapasrecord_dom_load(
				$next_xslt->getRealPath(),
				$xsltDOM,
				t("There seems to be an error on our end: 'Unable to find the XSLT validator'. Please open " .
					"a support ticket with this error message, and we'll get it fixed as quickly as possible!")
			);

			if ($xslt_error) {
				// It should never choke on finding the XSLT, since we're looking for it based on a directory
				// listinf of what's actually there. So if we do choke, something is very wrong somewhere, and
				// its better not to try to continue.
				$errors = array_merge($errors, $xslt_error);
				return $errors;
			}
			
			$proc = new \XSLTProcessor();
			$proc->importStylesheet($xsltDOM);
			$result = $proc->transformToXML($teiDOM);

			// if the result is FALSE, the xsl was unable to run.
			// if the result is a non-empty string, the xsl returned an error
			// if the result is an empty string, there were no errors.
			if ($result === FALSE) {
				$errors[] = t("Unable to run transform on this file. Are you sure its valid XML?");
			} elseif ($result) {
			  $errors[] = $result;
		  }
		}
	}

	return $errors;
}

/**
 * Does a DOMDocument::load, and handles the error checking 
 *
 * @param $filepath: The path of the file to load
 * @param &$theDOM: the DOMDocument object in which to load the file
 * @param $err_msg: the primary error to display if there are problems
 *
 * @return array() an array of error messages as text strings.
 *         (if there were no errors, the array will be empty)
 */
function _tapasrecord_dom_load($filepath, &$theDOM, $err_msg)
{

	$errors = array();
	// The error that the DOMDocument throws to the screen if the file is not
	// loadable is NOT an Exception, and CANNOT be caught with a try/catch block.
	// Therefore, in order to prevent the user from getting the raw libxml error
	// when they try to upload a non-xml file, we need to temporarily hijack
	// libxml's error handling.

	libxml_use_internal_errors(TRUE);

	if (!$theDOM->load($filepath)) {
		$errors[] = $err_msg;
		foreach (libxml_get_errors() as $e) {
			$errors[] = "(More info on why: " . $e->message . ")";
		}

		libxml_clear_errors();
		libxml_use_internal_errors(FALSE);
		return $errors;
	}

	// Give libxml back the ability to post errors
	libxml_use_internal_errors(FALSE);

	return $errors;
}

/**
 * Runs a libxml function, while taking control of the error display.
 * 
 * libxml displays errors on the webpage that cannot be caught as exceptions-- the only
 *    way (to my knowledge) is to temporarily hijack libxml's error reporting. I dislike
 *    supressing errors, but we want to be able to provide a non-confusing message if,
 *    for instance, the user tries to upload a non-xml file in the TEI field.
 *
 * @param &$obj: The object that will call the fuction
 * @param $func: The function name
 * @param $param: The parameter to feed to the function. (currently only one param supported.)
 * @param $err: A custom error message to display
 * @param $show_raw: whether to also show the raw XML messages, prefixed with "more info:"
 *
 * @return array(): An array of any non-suppressed errors
 */
function _tapasrecord_hijack_libxml_error_posting(&$obj, $func, $param, $err, $show_raw=TRUE) {

	assert(is_callable(array($obj, $func)));

	$errors = array();
	libxml_use_internal_errors(TRUE);

	$result = call_user_func(array($obj, $func), $param);

	if (!$result) {
		$errors[] = $err;
		if ($show_raw) {
			foreach (libxml_get_errors() as $e) {
				$errors[] = "(More info on why: " . $e->message . ")";
			}
		}

		libxml_clear_errors();
		libxml_use_internal_errors(FALSE);
		return $errors;
	}

	// Give libxml back the ability to post errors
	libxml_use_internal_errors(FALSE);

	return $errors;

}
