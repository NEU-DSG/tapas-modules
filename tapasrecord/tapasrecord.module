<?php

define("TAPAS_VALIDATION_XSLT_SUBDIRECTORY", "/validate/");
define("TAPAS_SAVE_FILE_ROOT_DIRECTORY", "public://tapasrecord");

/**
 * @file
 * tapasrecord.module TAPAS TEI upload and transformation
 * 
 * defines tapas_record conent type, performs
 * TEI upload and validation, calls TFC transform.
 */

/**
 * implements hook_node_info()
 *
 * Defines the TAPAS record content type
 *
 * I considered making this an entity rather than a node, since node brings
 * along extra baggage that we don't need. However, Drupal's access-control
 * system is node-based; therefore, it would be far more difficult to enforce
 * access restrictions on a custom entity than on a custom node type.
 */

function tapasrecord_node_info()
{
  return array(
    'tapasrecordnode' => array(
      'name' => t('TAPAS Record'),
      'base' => 'tapasrecordnode',
      'description' => t('Holds a TEI record along with it\'s associated metadata and TFC'),
      'has_title' => TRUE,
      'title_label' => t('Record Title'),
      'help' => '',
    ),
  );
}

/** 
 * implements hook_form()
 * 
 * This has to be present even if it's just a pass-through,
 * otherwise the content type won't appear in the 
 * admin/structure/types list (I have no idea what the
 * connection is, or why)
 */
function tapasrecordnode_form($node, $form_state) {
  return node_content_form($node, $form_state);
}

/** 
 * Implements hook_form_FORM_ID_alter().
 */

// Node creation/editing form should not show the TFC file field.
function tapasrecord_form_tapasrecordnode_node_form_alter(&$form, &$form_state, $form_id) {

	// hide the TFC field
	$form['tapas_tfcfield']['#access'] = FALSE;


	// TAPAS TEI field
	$form['tapas_teifield'][LANGUAGE_NONE][0] = array_merge(
    $form['tapas_teifield'][LANGUAGE_NONE][0],
		_tapasrecord_form_teifield($form_id)
	);

  // TODO: if this is a new (rather than edited) node, make tei field mandatory

}

function _tapasrecord_form_teifield($form_id)
{
	return array(
		'#type' => 'managed_file',
		'#title' => t('TEI file'),
		'#description' => t('allowed extentions: .tei, .xml'),
		'#upload_location' => _tapasrecord_get_file_upload_location(),
		'#upload_validators' => array(
			'file_validate_extensions' => array('tei xml'),
			'tapasrecord_validate_tei' => array($form_id),
		),
  );

}

function _tapasrecord_get_file_upload_location() {
	// TODO: will add subdirectories for project and collections, and add a directory_prepare
	return TAPAS_SAVE_FILE_ROOT_DIRECTORY;
}

/**
 * Callback to run the validation XSLT checks on the TEI file.
 *
 */
function tapasrecord_validate_tei($file, $form_id) {

	return _validate_xslt($file);
}

function tapasrecord_form_tapasrecordnode_node_form_submit($form, &$form_state) {
	// TODO: if new node or new TEI file, create TFC and attach/replace
}


function _validate_xslt($tei_file) {

	$errors = array();


	// The error that the DOMDocument throws to the screen if the file is not
	// loadable is NOT an Exception, and CANNOT be caught with a try/catch block.
	// Therefore, in order to prevent the user from getting an libxml error when they
	// try to upload a non-xml file, we need to temporarily hijack libxml's error
	// handling.
	libxml_use_internal_errors(TRUE);

	$teiDOM = new DOMDocument();
	if (!$teiDOM->load($tei_file->uri)) {
		$errors[] = "Unable to read the TEI file.";
		foreach (libxml_get_errors() as $e) {
			$errors[] = "(More info on why: " . $e->message . ")";
		}

		libxml_clear_errors();
		libxml_use_internal_errors(FALSE);
		return $errors;
	}

	// Give libxml back the ability to post errors
	libxml_use_internal_errors(FALSE);

	$xsltDOM = new DOMDocument();
	$xslt_path = drupal_get_path('module', 'tapasrecord') . TAPAS_VALIDATION_XSLT_SUBDIRECTORY;
	$iterator = new \DirectoryIterator($xslt_path);

	foreach ($iterator as $next_xslt) {
		$ext = $next_xslt->getExtension();
		if ($ext == 'xsl' || $ext == 'xslt') {

			// Create an XSLT Processor with the XSLT file found.
			$xsltDOM->load($next_xslt->getRealPath());
			$proc = new \XSLTProcessor();
			$proc->importStylesheet($xsltDOM);
			$result = $proc->transformToXML($teiDOM);

			// if the result is FALSE, the xsl was unable to run.
			// if the result is a non-empty string, the xsl returned an error
			// if the result is an empty string, there were no errors.
			if ($result === FALSE) {
				$errors[] = "Unable to run transform on this file. Are you sure its valid XML?";
			} elseif ($result) {
			  $errors[] = $result;
		  }
		}
	}
	return $errors;
}

/**
 * Run an XSLT Transform on an XML File
 *
 * Used to run the TFC transform on the original TEI file, but
 * function is more general.
 *
 * Eventually the actual transform will be moved to eXist, at
 * which point this function can be removed if it isn't being
 * used by any other process.
 *
 * @param $tei_file
 * @param $xslt_file
 * @param &$tfc_file
 *
 * @return
 */
function _run_transform($tei_file, $xslt_file, &$tfc_file) {

	$teiDOM = new DOMDocument();
	$teiDOM->load($tei_file);

	$xsltDOM = new DOMDocument();
	$xsltDOM-> load($xslt_file);

	$proc = new XSLTProcessor();
	$proc->importStylesheet($xsltDOM);	

	$tfc = new DOMDocument();
	$tfc->loadXML($proc->transformToXML($teiDOM));

	// Handle any errors
	// Write result to file
}


/**
 * TAPAS upload form validation callback
 */

// Verify that the record has a file attatched
// Verify that this file has the correct extention
// if _validate_xslt($tei_file), then set the error messages on the form


/**
 * TAPAS submit button
 */

