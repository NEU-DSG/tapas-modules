<?php

/**
 * @file
 * tapascontent.module
 *
 * @author Linda Moss (GitHub LindaJeanne) <l.moss@neu.edu>
 * @since 2.0
 * @version 2.1
 *
 * @TODO: Enfore Record group must 1. be Collection (not project) 2. Collections from same group.
 */

//include_once('tapascontent_constants.inc');
include_once('tapascontent_hydra.inc');
include_once('tapascontent_recordview.inc');
include_once('tapascontent_solr_indexing.inc');
include_once('tapascontent_forms.inc');

// ====================================================================================
// Functions implementing hooks
// ====================================================================================

/**
 * Imlements hook_node_info().
 */

function tapascontent_node_info() {
	$items = array(
		TAPAS_SHARED => array(
			'name' => t('TAPAS Shared Repository'),
			'base' => 'node_content',
			'description' => TAPAS_CONTENT_SHARED_DESC,
			'has_title' => TRUE,
			'title_label' => 'Shared Repository Title',
			'help' => TAPAS_CONTENT_SHARED_HELP,
		),
		TAPAS_PROJECT => array(
			'name' => t('TAPAS Project'),
			'base' => 'node_content',
			'description' => TAPAS_CONTENT_PROJ_DESC,
			'has_title' => TRUE,
			'title_label' => t('Project Title'),
			'help' => TAPAS_CONTENT_PROJ_HELP,
		),
		TAPAS_COLLECTION => array(
			'name' => t('TAPAS Collection'),
			'base' => 'node_content',
			'description' => TAPAS_CONTENT_COLL_DESC,
			'has_title' => TRUE,
			'title_label' => t('Collection Title'),
			'help' => TAPAS_CONTENT_COLL_HELP,
		),
		TAPAS_RECORD => array(
			'name' => t('TAPAS TEI Record'),
			'base' => 'node_content',
			'description' => TAPAS_CONTENT_REC_DESC,
			'has_title' => TRUE,
			'title_label' => t('Display Title'),
			'help' => TAPAS_CONTENT_REC_HELP,
		)
	);

	drupal_alter('node_info', $items);
	return $items;

}

/**
 * Implements hook_form().
 *
 * Debugging Note: this has to be present, even if it's just a pass-trough,
 *   otherwise the content type won't appear in the admin/structure/types list.
 */

function tapascontent_form($node, $form_state) {
	return node_content_form($node, $form_state);
}

/**
 * Implements hook_node_postinsert().
 */

function tapascontent_node_postinsert($node) {
  _tapascontent_insert_update($node);
}

/**
 * Implements hook_node_insert().
 */

function tapascontent_node_postupdate($node) {
	_tapascontent_insert_update($node);
}

/**
 * Implements hook_node_delete().
 *
 * Calls the Hydra API to delete the record.
 */
function tapascontent_node_delete($node) {

	//drupal_set_message("node delete called against type: " . $node->type);

	switch($node->type) {
	case TAPAS_PROJECT:
		tapashydra_delete(TAPAS_POST_PROJECT_URL, $node);
		break;
	case TAPAS_COLLECTION:
		tapashydra_delete(TAPAS_POST_COLLECTION_URL, $node);
		break;
	case TAPAS_RECORD:
		tapashydra_delete(TAPAS_POST_TEI_URL, $node);
		break;
 }

}


/**
 * Implements hook_node_view
 */

function tapascontent_node_view($node, $view_mode, $langcode) {
	if ($node->type == TAPAS_RECORD && $view_mode == 'full') {
		tapascontent_view_tei_record($node);
	}
}

function tapascontent_preprocess_node(&$variables){
  $node = $variables['elements']['#node'];
  switch($node->type){
    case 'tapas_record':
      // dpm($node);
      $groups = field_group_read_groups(array(
        'name' => 'node',
        'bundle' => 'tapas_record',
        'view_mode' => 'full'));
      $reader_group = $groups['node']['tapas_record']['full']['group_record_reader_content'];
      $reader_group->children[] = 'tapas_tab_reader';
      field_group_group_save($reader_group);
			$meta_group = $groups['node']['tapas_record']['full']['group_record_metadata_content'];
			$meta_group->children[] = 'tapas_tab_meta';
			field_group_group_save($meta_group);
      break;
  }
}

// ====================================================================================
// Helper functions
// ====================================================================================

/**
 * Internal. Returns a list of user-ids that are a member of the given project or collection.
 *
 * @param $node: The project or collection node
 * @return array: A list of user-ids of users who are members of the group represented by $node
 */

function _tapascontent_get_group_members($node) {
	return og_get_group_members_properties($node, [], OG_STATE_ACTIVE, 'node');
}

/**
 * @internal Get Slug from NodeId
 *
 * @param int $nodid the Drupal nid for the project/collection/record node.
 * @return string The contents of the slug field.
 */

function _tapascontent_slug_from_nid($nodeid) {

	//drupal_set_message("getting slug for $nodeid");

	$item = field_get_items(
		'node',
		node_load($nodeid),
		TAPAS_FIELD_PREFIX . 'slug'
	);

	return $item[0]['value'];
}

/**
 * @internal Get array of parent-slugs for a node.
 *
 * @param node An OG Content node.
 * @param array An array of strings, containing slugs. (or FALSE)
 */

function _tapascontent_get_parent_uuids($node) {

	$parent_ids = og_get_entity_groups('node', $node);

	if (!$parent_ids) {
		//drupal_set_message("No parents found.");
		return FALSE;
	}

	foreach ($parent_ids['node'] as $parent) {
		$node = node_load($parent);
		$ids[] = $node->uuid;
	}

	return $ids;
}

// This function currently handles populating the field_tapas_parent_slug field, 
// which I hacked into existence so that we could get working path rewrites
// for collections and records.
function tapascontent_node_presave($node) { 
  switch($node->type) { 
  case TAPAS_PROJECT : 
    break;
  case TAPAS_COLLECTION : 
    _tapascontent_watchdog("Running node presave hook", WATCHDOG_NOTICE);
    $parent_id = $node->og_tapas_c_to_p['und'][0]['target_id'];
    $project = node_load($parent_id);

    _tapascontent_watchdog("Attempted to load project", WATCHDOG_NOTICE);

    if ($project) { 
      $parent_slug = $project->field_tapas_slug['und'][0]['safe_value'];
      $node->field_tapas_parent_slug['und'][0]['value'] = $parent_slug;
      $node->field_tapas_parent_slug['und'][0]['safe_value'] = $parent_slug;
    } else { 
      $title = $node->title;
      _tapascontent_watchdog("Collection '$title' failed to find its parent".
        " record.", WATCHDOG_ERROR);
    }
    break;
  case TAPAS_RECORD : 
    $parent_id = $node->og_tapas_r_to_c['und'][0]['target_id'];
    $collection = node_load($parent_id); 

    if ($collection) { 
      $project_id = $collection->og_tapas_c_to_p['und'][0]['target_id'];
      $project = node_load($project_id);

      if ($project) { 
        $project_slug = $project->field_tapas_slug['und'][0]['safe_value'];
        $node->field_tapas_parent_slug['und'][0]['value'] = $project_slug;
        $node->field_tapas_parent_slug['und'][0]['safe_value'] = $project_slug;

        $node->field_tapas_project['und'][0]['target_id'] = $project->nid;
      } else {
        $title = $node->title;
        _tapascontent_watchdog("Record '$title' failed to find its project",
          WATCHDOG_ERROR);
      }
    } else { 
      $title = $node->title;
      _tapascontent_watchdog("Record '$title' failed to finds its collection");
    }
    break;
  }
}

/**
 * @internal Performs the POST for inserts and for updates.
 *
 * @param node $node The node object being created or updated.
 */
function _tapascontent_insert_update($node) {
  switch($node->type) {
    case TAPAS_PROJECT:
      $members = _tapascontent_get_group_members($node);
      $data = _tapascontent_projcol_hydradata($node);
      foreach($members as $key => $value) {
        $data["members"."[$key]"] = $value;
      }
      watchdog('debug_tapascontent_insert_update', '<pre>'. print_r($data, TRUE).'</pre>');
      tapashydra_post($data, TAPAS_POST_PROJECT_URL);
      _tapascontent_insert_update_common_tasks($node);
      break;
    case TAPAS_COLLECTION:
      watchdog('debug_tapascontent_insert_update', "Insert/Update called for TAPAS_COLLECTION");
      $data = _tapascontent_projcol_hydradata($node);
      $proj_as_array = _tapascontent_get_parent_uuids($node);
      $data['project_did'] = $proj_as_array[0];
      watchdog('debug_tapascontent_insert_update', '<pre>'. print_r($data, TRUE).'</pre>');
      tapashydra_post($data, TAPAS_POST_COLLECTION_URL);
      _tapascontent_insert_update_common_tasks($node);
      break;
    case TAPAS_RECORD:
      $data = _tapascontent_record_hydradata($node);
      tapashydra_post($data, TAPAS_POST_TEI_URL);
      _tapascontent_insert_update_common_tasks($node);
      watchdog('debug_tapascontent_insert_update', '<pre>'. print_r($data, TRUE).'</pre>');
      break;
  }
}

function _tapascontent_insert_update_common_tasks($node) { 
  // Index the content
  $node = node_load($node->nid);
  _tapascontent_index_content($node);
}

// ====================================================================================
// CURL call data arrays
// ====================================================================================

/**
 * @internal Post-data common to Projects and Collections.
 *
 * @param node $node: the node we will be posting.
 * @return array: An array with the common values set.
 */

function _tapascontent_projcol_hydradata($node) {

	$result =  array(
		'uniqueid' => $node->uuid,
		'depositor' => $node->uid,
		'title' => $node->title,
		'description' => tapas_simple_fieldval($node, TAPAS_FIELD_PREFIX . 'description'),
		'access' => $node->group_access['und'][0]['value']?'private':'public',
	);

	$thumb_file = tapashydra_filestring_from_field($node, TAPAS_FIELD_PREFIX . 'thumbnail');
	if (isset($thumb_file)) {
		$result['thumbnail']=$thumb_file;
	}

	return $result;
}

/**
 * @internal Post-data for Records
 *
 * @param node $node: The containing the post info.
 * @param string $uniqueid: The (non-drupal node-id) persistant unique id.
 *
 * @return array: an array with the $data elements.
 */

function _tapascontent_record_hydradata($node) {

  // Populate all items that certainly should exist
	$data = array(
		'uniqueid' => $node->uuid,
		'depositor' => $node->uid,
    'display_title' => $node->title,
    'collection_dids' => _tapascontent_get_parent_uuids($node),
	);

  $file_types = [];
  _tapascontent_assign_if_present($data, 'file_types', $file_types);

  $tf = TAPAS_FIELD_PREFIX;

  $display_date = tapas_simple_fieldval($node, $tf . 'display_date');
  _tapascontent_assign_if_present($data, 'display_date', $display_date);

  $tei = tapashydra_filestring_from_field($node, $tf . 'tei_file');
  _tapascontent_assign_if_present($data, 'tei', $tei);

  $authors = tapas_array_fieldval($node, $tf . 'display_auth');
  _tapascontent_assign_if_present($data, 'display_authors', $authors);

  $contribs = tapas_array_fieldval($node, $tf . 'display_contrib');
  _tapascontent_assign_if_present($data, 'display_contributors', $contribs);

  $sfs = _tapascontent_zip_from_support_files($node);
  _tapascontent_assign_if_present($data, 'support_files', $sfs);

  $ography_types = tapas_array_fieldval($node, $tf . 'record_ography_type');

  // Passing an empty array ensures that a record that was once marked as an
  // ography has these associations cleared in the repository.
  if (!$ography_types) {
    $ography_types = [null];
  }

  _tapascontent_assign_if_present($data, 'file_types', $ography_types);

	return $data;
}

function _tapascontent_zip_from_support_files($node) {
  $files = tapashydra_filearray_from_field($node, 'field_tapas_attachments');

  if(empty($files)) {
    return '';
  }

  $zip = new ZipArchive();
  $name = $node->nid . "_zip.zip";
  $filename = drupal_realpath("public://$name");

  $status = $zip->open($filename, ZipArchive::OVERWRITE);

  if($status !== true) {
    $err = "Drupal zip creation failed for node with nid $node->nid." .
      "Error message was: " . $zip->getStatusString();
    _tapascontent_watchdog($err, WATCHDOG_CRITICAL);
    return '';
  }

  foreach($files as $file) {
    $basename = basename($file);
    $zip->addFile($file, "$name/page_images/$basename");
  }

  $zip->close();
  return '@'.$filename;
}

function _tapascontent_assign_if_present(&$data, $key, $val) {

  if (is_string($val)) {
    $has_content = !(ctype_space($val)) && !(empty($val));
  } elseif (is_array($val)) {
    $has_content = !(empty($val));
  } else {
    return;
  }

  if ($has_content) {
    $data[$key] = $val;
  }
}

function _tapascontent_watchdog($msg, $err_level = WATCHDOG_DEBUG) {
  watchdog('tapascontent', $msg, array(), $err_level);
}

// Implements hook_user_login to perform wild apricot checking
function tapascontent_user_login(&$edit, $user) {
  $key = variable_get('wild_apricot_api_key', false);

  // No API key set - this is a dev environment and we don't care
  // about paid vs nonpaid members.  Skip.
  if (!$key) {
    return null;
  }

  $member_rid = user_role_load_by_name('paidmember')->rid;

  // Checks if Wild Apricot says the user is a paid member
  $is_paid_member = _tapascontent_is_paid_member($user->mail);

  // Checks if the user is currently flagged as a paid member
  $currently_member = array_key_exists($member_rid, $user->roles);

  if (($is_paid_member === true) and ($currently_member === false)) {
    user_multiple_role_edit([$user->uid], 'add_role', $member_rid);
    //drupal_set_message("TEI Membership confirmed, you now have full access to the TAPAS service.");
  } elseif (($is_paid_member === false) and ($currently_member === true)) {
    user_multiple_role_edit([$user->uid], 'remove_role', $member_rid);
    $msg = "Our records indicate that you are no longer a TEI Member.  You now have limited access to" .
      " the TAPAS Service.  If this was done in error, please contact us.";
    //drupal_set_message($msg);
  } elseif ($is_paid_member === null) {
    $msg = "Failed to contact Wild Apricot about membership status of"
      . " $user->mail.   Proceeding without changes made to user status";
    _tapascontent_watchdog($msg, WATCHDOG_NOTICE);
  }
}

// Fair Warning: If you call this function from boris multiple times every call
// after the first will hang on getting $async_result back and eventually the
// function returns null.  I have 100% no idea why this is happening, but it
// doesn't seem to be buggy outside of the boris environment.
function _tapascontent_is_paid_member($email) {
  $key = variable_get('wild_apricot_api_key', false);
  $aid = '66796';

  $query_url  = "https://api.wildapricot.org/v1/Accounts/$aid/Contacts?apikey=$key&\$filter=";
  $query_url .= "'e-Mail'%20eq%20'".$email."'";
  $query_url .= "&\$select='Membership%20Status'";

  // This is the JSON response returned by the API call in toto
  $async_result = _tapascontent_curl_get_apricot($query_url);

  // Check the WildApricot server once every ten seconds or until our
  // query is complete.
  $i = 0;
  while((($async_result === null) or ($async_result->State != 'Complete')) and ($i <= 10)) {
    sleep(1);
    $async_result = _tapascontent_curl_get_apricot($query_url);
    $i += 1;
  }

  if(is_object($async_result) and ($async_result->State === 'Complete')) {
    $result_url = $async_result->ResultUrl."&apikey=$key";
    $result = _tapascontent_curl_get_apricot($result_url);

    // In the case where $result is null, goofily loop hoping that Wild Apricot
    // will snap out of it.
    $step_two_i = 0;
    while(($result === null) and ($step_two_i <= 10)) {
      sleep(1);
      $result = _tapascontent_curl_get_apricot($result_url);
      $step_two_i += 1;
    }

    if ($result === null) {
      return null;
    }

    $users = $result->Contacts;
    $user_count = count($users);

    // In the case where no users were returned, the email address
    // we entered is associated with a user that doesn't exist according to
    // the TEIC.  Not a paid member.
    if($user_count === 0) {
      return false;
    }

    // Too many users were returned by the query -
    // email addresses should not be ambiguous so we return null
    if($user_count > 1) {
      $msg = "Wild Apricot returned $user_count users when asked for the user" .
        " with email address $email.  Skipping paid member status grant/revoke.";
      _tapascontent_watchdog($msg, WATCHDOG_ERROR);
      return null;
    }

    $status = $users[0]->Status;

    if ($status === 'Active') {
      return true;
    } elseif ($status != null) {
      return false;
    } else {
      return null;
    }
  } else {
    return null;
  }
}

function _tapascontent_curl_get_apricot($url) {
  $curl = curl_init($url);
  curl_setopt($curl, CURLOPT_HTTPHEADER, ["Accept: application/json"]);
  curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);

  $result = json_decode(curl_exec($curl));
  curl_close($curl);
  return($result);
}
